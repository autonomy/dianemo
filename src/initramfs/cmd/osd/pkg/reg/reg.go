//+build linux

package reg

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/autonomy/dianemo/src/initramfs/cmd/init/pkg/constants"
	servicelog "github.com/autonomy/dianemo/src/initramfs/cmd/init/pkg/service/log"
	"github.com/autonomy/dianemo/src/initramfs/cmd/osd/proto"
	"github.com/autonomy/dianemo/src/initramfs/pkg/chunker"
	filechunker "github.com/autonomy/dianemo/src/initramfs/pkg/chunker/file"
	streamchunker "github.com/autonomy/dianemo/src/initramfs/pkg/chunker/stream"
	"github.com/autonomy/dianemo/src/initramfs/pkg/userdata"
	"github.com/autonomy/dianemo/src/initramfs/pkg/version"
	dockerclient "github.com/docker/engine-api/client"
	"github.com/docker/engine-api/types"
	"github.com/golang/protobuf/ptypes/empty"
	crioclient "github.com/kubernetes-incubator/cri-o/client"
	"golang.org/x/sys/unix"
	"google.golang.org/grpc"
)

// Registrator is the concrete type that implements the factory.Registrator and
// proto.OSDServer interfaces.
type Registrator struct {
	Data *userdata.UserData
}

// Register implements the factory.Registrator interface.
func (r *Registrator) Register(s *grpc.Server) {
	proto.RegisterOSDServer(s, r)
}

// Kubeconfig implements the proto.OSDServer interface. The admin kubeconfig is
// generated by kubeadm and placed at /etc/kubernetes/admin.conf. This method
// returns the contents of the generated admin.conf in the response.
func (r *Registrator) Kubeconfig(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	fileBytes, err := ioutil.ReadFile("/etc/kubernetes/admin.conf")
	if err != nil {
		return
	}
	data = &proto.Data{
		Bytes: fileBytes,
	}

	return data, err
}

// Processes implements the proto.OSDServer interface.
func (r *Registrator) Processes(ctx context.Context, in *empty.Empty) (reply *proto.ProcessesReply, err error) {
	cli, err := dockerclient.NewEnvClient()
	if err != nil {
		return
	}
	containers, err := cli.ContainerList(context.Background(), types.ContainerListOptions{
		All: true,
	})
	if err != nil {
		return
	}
	var processes []*proto.Process
	for _, container := range containers {
		process := &proto.Process{
			Id:     container.ID,
			Name:   strings.TrimPrefix(container.Names[0], "/"),
			State:  container.State,
			Status: container.Status,
		}
		processes = append(processes, process)
	}

	reply = &proto.ProcessesReply{Processes: processes}

	return
}

// Restart implements the proto.OSDServer interface.
func (r *Registrator) Restart(ctx context.Context, in *proto.RestartRequest) (reply *proto.RestartReply, err error) {
	cli, err := dockerclient.NewEnvClient()
	if err != nil {
		return
	}
	duration := time.Duration(in.Timeout) * time.Second
	err = cli.ContainerRestart(context.Background(), in.Id, &duration)
	if err != nil {
		return
	}

	reply = &proto.RestartReply{}

	return
}

// Reset implements the proto.OSDServer interface.
func (r *Registrator) Reset(ctx context.Context, in *empty.Empty) (reply *proto.ResetReply, err error) {

	{
		cmd := exec.Command("/bin/docker", "stop", "kubelet")

		// Set the environment for the service.
		cmd.Env = []string{fmt.Sprintf("PATH=%s", constants.PATH)}

		if err = cmd.Start(); err != nil {
			return
		}
		_, err = cmd.Process.Wait()
		if err != nil {
			return
		}
	}

	args := []string{
		"run",
		"--rm",
		"--net=host",
		"--pid=host",
		"--privileged",
		"--volume=/sys:/sys:rw",
		"--volume=/sys/fs/cgroup:/sys/fs/cgroup:rw",
		"--volume=/var/run:/var/run:rw",
		"--volume=/run:/run:rw",
		"--volume=/var/lib/docker:/var/lib/docker:rw",
		"--volume=/var/lib/kubelet:/var/lib/kubelet:slave",
		"--volume=/var/log:/var/log",
		"--volume=/etc/kubernetes:/etc/kubernetes:shared",
		"--volume=/etc/os-release:/etc/os-release:ro",
		"--volume=/lib/modules:/lib/modules:ro",
		"--volume=/bin/docker:/bin/docker:ro",
		"--volume=/bin/crictl:/bin/crictl:ro",
		"--volume=/bin/kubeadm:/bin/kubeadm:ro",
		"--name=kubeadm",
		"gcr.io/google_containers/hyperkube:v1.11.2",
		"/bin/kubeadm",
		"reset",
		"--force",
	}

	// Build the exec.Cmd
	cmd := exec.Command("/bin/docker", args...)

	// Set the environment for the service.
	cmd.Env = []string{fmt.Sprintf("PATH=%s", constants.PATH)}

	if err = cmd.Start(); err != nil {
		return
	}
	_, err = cmd.Process.Wait()
	if err != nil {
		return
	}

	reply = &proto.ResetReply{}

	return
}

// Reboot implements the proto.OSDServer interface.
func (r *Registrator) Reboot(ctx context.Context, in *empty.Empty) (reply *proto.RebootReply, err error) {
	unix.Reboot(int(unix.LINUX_REBOOT_CMD_RESTART))

	reply = &proto.RebootReply{}

	return
}

// Dmesg implements the proto.OSDServer interface. The klogctl syscall is used
// to read from the ring buffer at /proc/kmsg by taking the
// SYSLOG_ACTION_READ_ALL action. This action reads all messages remaining in
// the ring buffer non-destructively.
func (r *Registrator) Dmesg(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	// Return the size of the kernel ring buffer
	size, err := unix.Klogctl(constants.SYSLOG_ACTION_SIZE_BUFFER, nil)
	if err != nil {
		return
	}
	// Read all messages from the log (non-destructively)
	buf := make([]byte, size)
	n, err := unix.Klogctl(constants.SYSLOG_ACTION_READ_ALL, buf)
	if err != nil {
		return
	}

	data = &proto.Data{Bytes: buf[:n]}

	return data, err
}

// Logs implements the proto.OSDServer interface. Service or container logs can
// be requested and the contents of the log file are streamed in chunks.
func (r *Registrator) Logs(req *proto.LogsRequest, l proto.OSD_LogsServer) (err error) {
	var chunk chunker.ChunkReader
	if req.Container {
		switch r.Data.Services.Kubeadm.ContainerRuntime {
		case constants.ContainerRuntimeDocker:
			chunk, err = dockerLogs(req.Process)
			if err != nil {
				return
			}
		case constants.ContainerRuntimeCRIO:
			chunk, err = crioLogs(req.Process)
			if err != nil {
				return
			}
		}
	} else {
		logpath := servicelog.FormatLogPath(req.Process)
		file, _err := os.OpenFile(logpath, os.O_RDONLY, 0)
		if _err != nil {
			err = _err
			return
		}
		chunk = filechunker.NewChunker(file)
	}

	if chunk == nil {
		return fmt.Errorf("no log reader found")
	}

	for data := range chunk.Read(l.Context()) {
		if err = l.Send(&proto.Data{Bytes: data}); err != nil {
			return
		}
	}

	return nil
}

// Version implements the proto.OSDServer interface.
func (r *Registrator) Version(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	v, err := version.NewVersion()
	if err != nil {
		return
	}

	data = &proto.Data{Bytes: []byte(v)}

	return data, err
}
func crioLogs(id string) (chunk chunker.Chunker, err error) {
	cli, err := crioclient.New(constants.ContainerRuntimeCRIOSocket)
	if err != nil {
		return
	}
	info, err := cli.ContainerInfo(id)
	if err != nil {
		return
	}
	file, err := os.OpenFile(info.LogPath, os.O_RDONLY, 0)
	if err != nil {
		return
	}
	chunk = filechunker.NewChunker(file)

	return chunk, nil
}

func dockerLogs(id string) (chunk chunker.Chunker, err error) {
	cli, err := dockerclient.NewEnvClient()
	if err != nil {
		return
	}
	stream, err := cli.ContainerLogs(context.Background(), id, types.ContainerLogsOptions{
		ShowStderr: true,
		ShowStdout: true,
		Timestamps: false,
		Follow:     true,
		Tail:       "40",
	})
	if err != nil {
		return
	}

	chunk = streamchunker.NewChunker(stream)

	return chunk, nil
}
