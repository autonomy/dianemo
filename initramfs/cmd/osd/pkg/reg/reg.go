//+build linux

package reg

import (
	"context"
	"io/ioutil"
	"os"

	"github.com/autonomy/dianemo/initramfs/cmd/init/pkg/constants"
	servicelog "github.com/autonomy/dianemo/initramfs/cmd/init/pkg/service/log"
	"github.com/autonomy/dianemo/initramfs/cmd/osd/proto"
	"github.com/autonomy/dianemo/initramfs/pkg/chunker"
	"github.com/autonomy/dianemo/initramfs/pkg/version"
	"github.com/golang/protobuf/ptypes/empty"
	"github.com/kubernetes-incubator/cri-o/client"
	"golang.org/x/sys/unix"
	"google.golang.org/grpc"
)

// Registrator is the concrete type that implements the factory.Registrator and
// proto.OSDServer interfaces.
type Registrator struct{}

// Register implements the factory.Registrator interface.
func (r *Registrator) Register(s *grpc.Server) {
	proto.RegisterOSDServer(s, r)
}

// Kubeconfig implements the proto.OSDServer interface. The admin kubeconfig is
// generated by kubeadm and placed at /etc/kubernetes/admin.conf. This method
// returns the contents of the generated admin.conf in the response.
func (r *Registrator) Kubeconfig(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	fileBytes, err := ioutil.ReadFile("/etc/kubernetes/admin.conf")
	if err != nil {
		return
	}
	data = &proto.Data{
		Bytes: fileBytes,
	}

	return data, err
}

// Processes implements the proto.OSDServer interface.
func (r *Registrator) Processes(ctx context.Context, in *proto.ProcessesRequest) (reply *proto.ProcessesReply, err error) {
	return
}

// Dmesg implements the proto.OSDServer interface. The klogctl syscall is used
// to read from the ring buffer at /proc/kmsg by taking the
// SYSLOG_ACTION_READ_ALL action. This action reads all messages remaining in
// the ring buffer non-destructively.
func (r *Registrator) Dmesg(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	// Return the size of the kernel ring buffer
	size, err := unix.Klogctl(constants.SYSLOG_ACTION_SIZE_BUFFER, nil)
	if err != nil {
		return
	}
	// Read all messages from the log (non-destructively)
	buf := make([]byte, size)
	n, err := unix.Klogctl(constants.SYSLOG_ACTION_READ_ALL, buf)
	if err != nil {
		return
	}

	data = &proto.Data{Bytes: buf[:n]}

	return data, err
}

// Logs implements the proto.OSDServer interface. Service or container logs can
// be requested and the contents of the log file are streamed in chunks.
func (r *Registrator) Logs(req *proto.LogsRequest, l proto.OSD_LogsServer) (err error) {
	var chunk chunker.ChunkReader
	if req.Container {
		// TODO: Use the specified container runtime.
		cli, _err := client.New("/var/run/crio/crio.sock")
		if _err != nil {
			err = _err
			return
		}
		info, _err := cli.ContainerInfo(req.Process)
		if _err != nil {
			err = _err
			return
		}
		file, _err := os.OpenFile(info.LogPath, os.O_RDONLY, 0)
		if _err != nil {
			err = _err
			return
		}
		chunk = chunker.NewDefaultChunker(file)
	} else {
		logpath := servicelog.FormatLogPath(req.Process)
		file, _err := os.OpenFile(logpath, os.O_RDONLY, 0)
		if _err != nil {
			err = _err
			return
		}
		chunk = chunker.NewDefaultChunker(file)
	}

	for data := range chunk.Read(l.Context()) {
		if err = l.Send(&proto.Data{Bytes: data}); err != nil {
			return
		}
	}

	return nil
}

// Version implements the proto.OSDServer interface.
func (r *Registrator) Version(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	v, err := version.NewVersion()
	if err != nil {
		return
	}

	data = &proto.Data{Bytes: []byte(v)}

	return data, err
}
