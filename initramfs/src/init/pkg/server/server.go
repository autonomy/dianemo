//+build linux

package server

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"strconv"

	"github.com/autonomy/dianemo/initramfs/src/init/pkg/chunker"
	"github.com/autonomy/dianemo/initramfs/src/init/pkg/constants"
	servicelog "github.com/autonomy/dianemo/initramfs/src/init/pkg/service/log"
	"github.com/autonomy/dianemo/initramfs/src/init/pkg/userdata"
	"github.com/autonomy/dianemo/initramfs/src/init/proto"
	"github.com/golang/protobuf/ptypes/empty"
	"github.com/kubernetes-incubator/cri-o/client"
	"golang.org/x/sys/unix"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
)

// Server implements the proto.DianemoServer interface. It serves as the
// concrete type with the required methods.
type Server struct {
	server *grpc.Server
	port   int
	ca     string
	crt    string
	key    string
}

// NewServer initializes a Server.
func NewServer(data *userdata.Security) (s *Server) {
	s = &Server{
		port: 50000,
		ca:   data.CA.Crt,
		crt:  data.Identity.Crt,
		key:  data.Identity.Key,
	}

	return s
}

// Listen configures TLS for mutual authtentication by loading the CA into a
// CertPool and configuring the server's policy for TLS Client Authentication.
// Once TLS is configured, the gRPC options are built to make use of the TLS
// configuration and the receiver (Server) is registered to the gRPC server.
// Finally the gRPC server is started.
func (s *Server) Listen() (err error) {
	var (
		listener net.Listener
		grpcOpts = []grpc.ServerOption{}
	)
	caBytes, err := base64.StdEncoding.DecodeString(s.ca)
	if err != nil {
		return err
	}
	keyBytes, err := base64.StdEncoding.DecodeString(s.key)
	if err != nil {
		return err
	}
	crtBytes, err := base64.StdEncoding.DecodeString(s.crt)
	if err != nil {
		return err
	}
	listener, err = net.Listen("tcp", ":"+strconv.Itoa(s.port))
	if err != nil {
		return
	}

	crt, err := tls.X509KeyPair(crtBytes, keyBytes)
	if err != nil {
		return fmt.Errorf("could not load server key pair: %s", err)
	}
	certPool := x509.NewCertPool()
	if err != nil {
		return fmt.Errorf("could not read ca certificate: %s", err)
	}
	if ok := certPool.AppendCertsFromPEM(caBytes); !ok {
		return fmt.Errorf("failed to append client certs")
	}
	creds := credentials.NewTLS(&tls.Config{
		ClientAuth:   tls.RequireAndVerifyClientCert,
		Certificates: []tls.Certificate{crt},
		// Validate certificates against the provided CA.
		ClientCAs: certPool,
		// Perfect Forward Secrecy.
		CurvePreferences: []tls.CurveID{tls.X25519},
		CipherSuites:     []uint16{tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384},
		// Force the above cipher suites.
		PreferServerCipherSuites: true,
		// TLS 1.2
		MinVersion: tls.VersionTLS12,
	})
	grpcOpts = append(grpcOpts, grpc.Creds(creds))
	s.server = grpc.NewServer(grpcOpts...)
	proto.RegisterDianemoServer(s.server, s)

	log.Printf("Started gRPC on :%d", s.port)
	err = s.server.Serve(listener)
	if err != nil {
		return
	}

	return err
}

// Kubeconfig implements the proto.DianemoServer interface. The admin kubeconfig
// is generated by kubeadm and placed at /etc/kubernetes/admin.conf. This method
// returns the contents of the generated admin.conf and returns it in the
// response.
func (s *Server) Kubeconfig(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	fileBytes, err := ioutil.ReadFile("/etc/kubernetes/admin.conf")
	if err != nil {
		return
	}
	data = &proto.Data{
		Bytes: fileBytes,
	}

	return data, err
}

// Processes implements the proto.DianemoServer interface.
func (s *Server) Processes(ctx context.Context, in *proto.ProcessesRequest) (r *proto.ProcessesReply, err error) {
	return
}

// Dmesg implements the proto.DianemoServer interface. The klogctl syscall is
// used to read from the ring buffer at /proc/kmsg by taking the
// SYSLOG_ACTION_READ_ALL action. This action reads all messages remaining in
// the ring buffer non-destructively.
func (s *Server) Dmesg(ctx context.Context, in *empty.Empty) (data *proto.Data, err error) {
	// Return the size of the kernel ring buffer
	size, err := unix.Klogctl(constants.SYSLOG_ACTION_SIZE_BUFFER, nil)
	if err != nil {
		return
	}
	// Read all messages from the log (non-destructively)
	buf := make([]byte, size)
	n, err := unix.Klogctl(constants.SYSLOG_ACTION_READ_ALL, buf)
	if err != nil {
		return
	}

	data = &proto.Data{Bytes: buf[:n]}

	return data, err
}

// Logs implements the proto.DianemoServer interface. Service or container logs
// can be requested and the contents of the log file are streamed in chunks.
func (s *Server) Logs(r *proto.LogsRequest, l proto.Dianemo_LogsServer) (err error) {
	var chunk chunker.ChunkReader
	if r.Container {
		// TODO: Use the specified container runtime.
		cli, e := client.New("/var/run/crio/crio.sock")
		if e != nil {
			err = e
			return
		}
		info, e := cli.ContainerInfo(r.Process)
		if e != nil {
			err = e
			return
		}
		chunk = chunker.NewDefaultChunker(info.LogPath)
	} else {
		chunk = servicelog.Chunker(r.Process)
		if chunk == nil {
			err = fmt.Errorf("no such process: %s", r.Process)
			return
		}
	}

	for data := range chunk.Read(l.Context()) {
		if err = l.Send(&proto.Data{Bytes: data}); err != nil {
			return
		}
	}

	return err
}
