// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

package api

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	sync "sync"

	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	go_multierror "github.com/hashicorp/go-multierror"
	grpc "google.golang.org/grpc"
	credentials "google.golang.org/grpc/credentials"
	metadata "google.golang.org/grpc/metadata"

	common "github.com/talos-systems/talos/api/common"
	machine "github.com/talos-systems/talos/api/machine"
	network "github.com/talos-systems/talos/api/network"
	os "github.com/talos-systems/talos/api/os"
	time "github.com/talos-systems/talos/api/time"
	constants "github.com/talos-systems/talos/pkg/constants"
	tls "github.com/talos-systems/talos/pkg/grpc/tls"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = proto.Marshal
	_ = fmt.Errorf
	_ = math.Inf
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ContainersRequest from public import os/os.proto
type ContainersRequest = os.ContainersRequest

// Container from public import os/os.proto
type Container = os.Container

// ContainerResponse from public import os/os.proto
type ContainerResponse = os.ContainerResponse

// ContainersReply from public import os/os.proto
type ContainersReply = os.ContainersReply

// ProcessesRequest from public import os/os.proto
type ProcessesRequest = os.ProcessesRequest

// ProcessesReply from public import os/os.proto
type ProcessesReply = os.ProcessesReply

// ProcessResponse from public import os/os.proto
type ProcessResponse = os.ProcessResponse

// Process from public import os/os.proto
type Process = os.Process

// RestartRequest from public import os/os.proto
type RestartRequest = os.RestartRequest

// RestartResponse from public import os/os.proto
type RestartResponse = os.RestartResponse

// RestartReply from public import os/os.proto
type RestartReply = os.RestartReply

// StatsRequest from public import os/os.proto
type StatsRequest = os.StatsRequest

// StatsResponse from public import os/os.proto
type StatsResponse = os.StatsResponse

// StatsReply from public import os/os.proto
type StatsReply = os.StatsReply

// Stat from public import os/os.proto
type Stat = os.Stat

// MemInfoResponse from public import os/os.proto
type MemInfoResponse = os.MemInfoResponse

// MemInfoReply from public import os/os.proto
type MemInfoReply = os.MemInfoReply

// MemInfo from public import os/os.proto
type MemInfo = os.MemInfo

// RebootResponse from public import machine/machine.proto
type RebootResponse = machine.RebootResponse

// RebootReply from public import machine/machine.proto
type RebootReply = machine.RebootReply

// ResetResponse from public import machine/machine.proto
type ResetResponse = machine.ResetResponse

// ResetReply from public import machine/machine.proto
type ResetReply = machine.ResetReply

// ShutdownResponse from public import machine/machine.proto
type ShutdownResponse = machine.ShutdownResponse

// ShutdownReply from public import machine/machine.proto
type ShutdownReply = machine.ShutdownReply

// UpgradeRequest from public import machine/machine.proto
type UpgradeRequest = machine.UpgradeRequest

// UpgradeResponse from public import machine/machine.proto
type UpgradeResponse = machine.UpgradeResponse

// UpgradeReply from public import machine/machine.proto
type UpgradeReply = machine.UpgradeReply

// ServiceListResponse from public import machine/machine.proto
type ServiceListResponse = machine.ServiceListResponse

// ServiceListReply from public import machine/machine.proto
type ServiceListReply = machine.ServiceListReply

// ServiceInfo from public import machine/machine.proto
type ServiceInfo = machine.ServiceInfo

// ServiceEvents from public import machine/machine.proto
type ServiceEvents = machine.ServiceEvents

// ServiceEvent from public import machine/machine.proto
type ServiceEvent = machine.ServiceEvent

// ServiceHealth from public import machine/machine.proto
type ServiceHealth = machine.ServiceHealth

// ServiceStartRequest from public import machine/machine.proto
type ServiceStartRequest = machine.ServiceStartRequest

// ServiceStartResponse from public import machine/machine.proto
type ServiceStartResponse = machine.ServiceStartResponse

// ServiceStartReply from public import machine/machine.proto
type ServiceStartReply = machine.ServiceStartReply

// ServiceStopRequest from public import machine/machine.proto
type ServiceStopRequest = machine.ServiceStopRequest

// ServiceStopResponse from public import machine/machine.proto
type ServiceStopResponse = machine.ServiceStopResponse

// ServiceStopReply from public import machine/machine.proto
type ServiceStopReply = machine.ServiceStopReply

// ServiceRestartRequest from public import machine/machine.proto
type ServiceRestartRequest = machine.ServiceRestartRequest

// ServiceRestartResponse from public import machine/machine.proto
type ServiceRestartResponse = machine.ServiceRestartResponse

// ServiceRestartReply from public import machine/machine.proto
type ServiceRestartReply = machine.ServiceRestartReply

// StartRequest from public import machine/machine.proto
type StartRequest = machine.StartRequest

// StartReply from public import machine/machine.proto
type StartReply = machine.StartReply

// StopRequest from public import machine/machine.proto
type StopRequest = machine.StopRequest

// StopReply from public import machine/machine.proto
type StopReply = machine.StopReply

// StreamingData from public import machine/machine.proto
type StreamingData = machine.StreamingData

// CopyOutRequest from public import machine/machine.proto
type CopyOutRequest = machine.CopyOutRequest

// LSRequest from public import machine/machine.proto
type LSRequest = machine.LSRequest

// FileInfo from public import machine/machine.proto
type FileInfo = machine.FileInfo

// MountsResponse from public import machine/machine.proto
type MountsResponse = machine.MountsResponse

// MountsReply from public import machine/machine.proto
type MountsReply = machine.MountsReply

// MountStat from public import machine/machine.proto
type MountStat = machine.MountStat

// VersionResponse from public import machine/machine.proto
type VersionResponse = machine.VersionResponse

// VersionReply from public import machine/machine.proto
type VersionReply = machine.VersionReply

// VersionInfo from public import machine/machine.proto
type VersionInfo = machine.VersionInfo

// PlatformInfo from public import machine/machine.proto
type PlatformInfo = machine.PlatformInfo

// LogsRequest from public import machine/machine.proto
type LogsRequest = machine.LogsRequest

// ReadRequest from public import machine/machine.proto
type ReadRequest = machine.ReadRequest

// TimeRequest from public import time/time.proto
type TimeRequest = time.TimeRequest

// TimeReply from public import time/time.proto
type TimeReply = time.TimeReply

// TimeResponse from public import time/time.proto
type TimeResponse = time.TimeResponse

// RoutesReply from public import network/network.proto
type RoutesReply = network.RoutesReply

// RoutesResponse from public import network/network.proto
type RoutesResponse = network.RoutesResponse

// Route from public import network/network.proto
type Route = network.Route

// InterfacesReply from public import network/network.proto
type InterfacesReply = network.InterfacesReply

// InterfacesResponse from public import network/network.proto
type InterfacesResponse = network.InterfacesResponse

// Interface from public import network/network.proto
type Interface = network.Interface

// AddressFamily from public import network/network.proto
type AddressFamily = network.AddressFamily

var (
	AddressFamily_name  = network.AddressFamily_name
	AddressFamily_value = network.AddressFamily_value
)

const (
	AddressFamily_AF_UNSPEC = AddressFamily(network.AddressFamily_AF_UNSPEC)
	AddressFamily_AF_INET   = AddressFamily(network.AddressFamily_AF_INET)
	AddressFamily_IPV4      = AddressFamily(network.AddressFamily_IPV4)
	AddressFamily_AF_INET6  = AddressFamily(network.AddressFamily_AF_INET6)
	AddressFamily_IPV6      = AddressFamily(network.AddressFamily_IPV6)
)

// RouteProtocol from public import network/network.proto
type RouteProtocol = network.RouteProtocol

var (
	RouteProtocol_name  = network.RouteProtocol_name
	RouteProtocol_value = network.RouteProtocol_value
)

const (
	RouteProtocol_RTPROT_UNSPEC   = RouteProtocol(network.RouteProtocol_RTPROT_UNSPEC)
	RouteProtocol_RTPROT_REDIRECT = RouteProtocol(network.RouteProtocol_RTPROT_REDIRECT)
	RouteProtocol_RTPROT_KERNEL   = RouteProtocol(network.RouteProtocol_RTPROT_KERNEL)
	RouteProtocol_RTPROT_BOOT     = RouteProtocol(network.RouteProtocol_RTPROT_BOOT)
	RouteProtocol_RTPROT_STATIC   = RouteProtocol(network.RouteProtocol_RTPROT_STATIC)
	RouteProtocol_RTPROT_GATED    = RouteProtocol(network.RouteProtocol_RTPROT_GATED)
	RouteProtocol_RTPROT_RA       = RouteProtocol(network.RouteProtocol_RTPROT_RA)
	RouteProtocol_RTPROT_MRT      = RouteProtocol(network.RouteProtocol_RTPROT_MRT)
	RouteProtocol_RTPROT_ZEBRA    = RouteProtocol(network.RouteProtocol_RTPROT_ZEBRA)
	RouteProtocol_RTPROT_BIRD     = RouteProtocol(network.RouteProtocol_RTPROT_BIRD)
	RouteProtocol_RTPROT_DNROUTED = RouteProtocol(network.RouteProtocol_RTPROT_DNROUTED)
	RouteProtocol_RTPROT_XORP     = RouteProtocol(network.RouteProtocol_RTPROT_XORP)
	RouteProtocol_RTPROT_NTK      = RouteProtocol(network.RouteProtocol_RTPROT_NTK)
	RouteProtocol_RTPROT_DHCP     = RouteProtocol(network.RouteProtocol_RTPROT_DHCP)
	RouteProtocol_RTPROT_MROUTED  = RouteProtocol(network.RouteProtocol_RTPROT_MROUTED)
	RouteProtocol_RTPROT_BABEL    = RouteProtocol(network.RouteProtocol_RTPROT_BABEL)
)

// InterfaceFlags from public import network/network.proto
type InterfaceFlags = network.InterfaceFlags

var (
	InterfaceFlags_name  = network.InterfaceFlags_name
	InterfaceFlags_value = network.InterfaceFlags_value
)

const (
	InterfaceFlags_FLAG_UNKNOWN        = InterfaceFlags(network.InterfaceFlags_FLAG_UNKNOWN)
	InterfaceFlags_FLAG_UP             = InterfaceFlags(network.InterfaceFlags_FLAG_UP)
	InterfaceFlags_FLAG_BROADCAST      = InterfaceFlags(network.InterfaceFlags_FLAG_BROADCAST)
	InterfaceFlags_FLAG_LOOPBACK       = InterfaceFlags(network.InterfaceFlags_FLAG_LOOPBACK)
	InterfaceFlags_FLAG_POINT_TO_POINT = InterfaceFlags(network.InterfaceFlags_FLAG_POINT_TO_POINT)
	InterfaceFlags_FLAG_MULTICAST      = InterfaceFlags(network.InterfaceFlags_FLAG_MULTICAST)
)

// NodeMetadata from public import common/common.proto
type NodeMetadata = common.NodeMetadata

// Data from public import common/common.proto
type Data = common.Data

// DataResponse from public import common/common.proto
type DataResponse = common.DataResponse

// DataReply from public import common/common.proto
type DataReply = common.DataReply

// ContainerDriver from public import common/common.proto
type ContainerDriver = common.ContainerDriver

var (
	ContainerDriver_name  = common.ContainerDriver_name
	ContainerDriver_value = common.ContainerDriver_value
)

const (
	ContainerDriver_CONTAINERD = ContainerDriver(common.ContainerDriver_CONTAINERD)
	ContainerDriver_CRI        = ContainerDriver(common.ContainerDriver_CRI)
)

// Empty from public import google/protobuf/empty.proto
type Empty = empty.Empty

func init() { proto.RegisterFile("api.proto", fileDescriptor_00212fb1f9d3bf1c) }

var fileDescriptor_00212fb1f9d3bf1c = []byte{
	// 160 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x34, 0x8b, 0xb1, 0x0e, 0x82, 0x40,
	0x0c, 0x40, 0x55, 0xd4, 0x44, 0x1d, 0x4c, 0x34, 0x2e, 0xb8, 0x19, 0x57, 0xe9, 0xe0, 0x1f, 0xf8,
	0x05, 0x37, 0xbb, 0x1d, 0xa4, 0x42, 0x23, 0xa5, 0x17, 0x5a, 0x62, 0xf8, 0x7b, 0x23, 0x77, 0x2e,
	0x7d, 0x79, 0xaf, 0xed, 0x76, 0xe3, 0x03, 0x15, 0xa1, 0x17, 0x93, 0x43, 0xe6, 0x03, 0xe5, 0x3b,
	0x51, 0x10, 0x8d, 0x25, 0x3f, 0xb1, 0xaf, 0x1a, 0xea, 0x10, 0x12, 0x53, 0xde, 0x1b, 0x31, 0xc2,
	0x6f, 0xfc, 0xef, 0x3a, 0xb4, 0x8f, 0xf4, 0x6f, 0x48, 0x4c, 0xf9, 0x58, 0x09, 0xb3, 0x74, 0x10,
	0x91, 0xe2, 0xb9, 0x16, 0xa9, 0x5b, 0x84, 0xc9, 0xca, 0xe1, 0x05, 0xc8, 0xc1, 0xc6, 0xb8, 0x7c,
	0x5c, 0x9f, 0x97, 0x9a, 0xac, 0x19, 0xca, 0xa2, 0x12, 0x06, 0xf3, 0xad, 0xe8, 0x4d, 0x47, 0x35,
	0x64, 0x8d, 0x06, 0x3e, 0x90, 0x9b, 0xb9, 0xb9, 0x5b, 0xb8, 0xcc, 0x2d, 0xdd, 0xaa, 0x5c, 0x4f,
	0x8f, 0xf7, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x05, 0x8c, 0xe2, 0xe0, 0xc8, 0x00, 0x00, 0x00,
}

type ApiProxy struct {
	Provider tls.CertificateProvider
}

func NewApiProxy(provider tls.CertificateProvider) *ApiProxy {
	return &ApiProxy{
		Provider: provider,
	}
}

func (p *ApiProxy) UnaryInterceptor() grpc.UnaryServerInterceptor {
	return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		md, _ := metadata.FromIncomingContext(ctx)
		if _, ok := md["proxyfrom"]; ok {
			return handler(ctx, req)
		}
		ca, err := p.Provider.GetCA()
		if err != nil {
			return nil, err
		}
		certs, err := p.Provider.GetCertificate(nil)
		if err != nil {
			return nil, err
		}
		tlsConfig, err := tls.New(
			tls.WithClientAuthType(tls.Mutual),
			tls.WithCACertPEM(ca),
			tls.WithKeypair(*certs),
		)
		return p.UnaryProxy(ctx, info.FullMethod, credentials.NewTLS(tlsConfig), req)
	}
}

func (p *ApiProxy) UnaryProxy(ctx context.Context, method string, creds credentials.TransportCredentials, in interface{}, opts ...grpc.CallOption) (proto.Message, error) {
	var (
		err      error
		errors   *go_multierror.Error
		msgs     []proto.Message
		ok       bool
		response proto.Message
		targets  []string
	)
	md, _ := metadata.FromIncomingContext(ctx)
	// default to target node specified in config or on cli
	if targets, ok = md["targets"]; !ok {
		targets = md[":authority"]
	}
	proxyMd := metadata.New(make(map[string]string))
	proxyMd.Set("proxyfrom", md[":authority"]...)

	switch method {
	case "/os.OS/Containers":
		// Initialize target clients
		clients, err := createOSClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &os.ContainersReply{}
		msgs, err = proxyOSRunner(clients, in, proxyContainers)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*os.ContainersReply).Response[0])
		}
		response = resp
	case "/os.OS/Dmesg":
		// Initialize target clients
		clients, err := createOSClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &common.DataReply{}
		msgs, err = proxyOSRunner(clients, in, proxyDmesg)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*common.DataReply).Response[0])
		}
		response = resp
	case "/os.OS/Memory":
		// Initialize target clients
		clients, err := createOSClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &os.MemInfoReply{}
		msgs, err = proxyOSRunner(clients, in, proxyMemory)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*os.MemInfoReply).Response[0])
		}
		response = resp
	case "/os.OS/Processes":
		// Initialize target clients
		clients, err := createOSClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &os.ProcessesReply{}
		msgs, err = proxyOSRunner(clients, in, proxyProcesses)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*os.ProcessesReply).Response[0])
		}
		response = resp
	case "/os.OS/Restart":
		// Initialize target clients
		clients, err := createOSClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &os.RestartReply{}
		msgs, err = proxyOSRunner(clients, in, proxyRestart)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*os.RestartReply).Response[0])
		}
		response = resp
	case "/os.OS/Stats":
		// Initialize target clients
		clients, err := createOSClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &os.StatsReply{}
		msgs, err = proxyOSRunner(clients, in, proxyStats)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*os.StatsReply).Response[0])
		}
		response = resp
	case "/machine.Machine/Mounts":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.MountsReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyMounts)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.MountsReply).Response[0])
		}
		response = resp
	case "/machine.Machine/Reboot":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.RebootReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyReboot)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.RebootReply).Response[0])
		}
		response = resp
	case "/machine.Machine/Reset":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.ResetReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyReset)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.ResetReply).Response[0])
		}
		response = resp
	case "/machine.Machine/ServiceList":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.ServiceListReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyServiceList)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.ServiceListReply).Response[0])
		}
		response = resp
	case "/machine.Machine/ServiceRestart":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.ServiceRestartReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyServiceRestart)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.ServiceRestartReply).Response[0])
		}
		response = resp
	case "/machine.Machine/ServiceStart":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.ServiceStartReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyServiceStart)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.ServiceStartReply).Response[0])
		}
		response = resp
	case "/machine.Machine/ServiceStop":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.ServiceStopReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyServiceStop)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.ServiceStopReply).Response[0])
		}
		response = resp
	case "/machine.Machine/Shutdown":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.ShutdownReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyShutdown)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.ShutdownReply).Response[0])
		}
		response = resp
	case "/machine.Machine/Upgrade":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.UpgradeReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyUpgrade)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.UpgradeReply).Response[0])
		}
		response = resp
	case "/machine.Machine/Version":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &machine.VersionReply{}
		msgs, err = proxyMachineRunner(clients, in, proxyVersion)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*machine.VersionReply).Response[0])
		}
		response = resp
	case "/time.Time/Time":
		// Initialize target clients
		clients, err := createTimeClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &time.TimeReply{}
		msgs, err = proxyTimeRunner(clients, in, proxyTime)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*time.TimeReply).Response[0])
		}
		response = resp
	case "/time.Time/TimeCheck":
		// Initialize target clients
		clients, err := createTimeClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &time.TimeReply{}
		msgs, err = proxyTimeRunner(clients, in, proxyTimeCheck)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*time.TimeReply).Response[0])
		}
		response = resp
	case "/network.Network/Routes":
		// Initialize target clients
		clients, err := createNetworkClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &network.RoutesReply{}
		msgs, err = proxyNetworkRunner(clients, in, proxyRoutes)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*network.RoutesReply).Response[0])
		}
		response = resp
	case "/network.Network/Interfaces":
		// Initialize target clients
		clients, err := createNetworkClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		resp := &network.InterfacesReply{}
		msgs, err = proxyNetworkRunner(clients, in, proxyInterfaces)
		for _, msg := range msgs {
			resp.Response = append(resp.Response, msg.(*network.InterfacesReply).Response[0])
		}
		response = resp

	}

	if err != nil {
		errors = go_multierror.Append(errors, err)
	}
	return response, errors.ErrorOrNil()
}

func copyClientServer(msg interface{}, client grpc.ClientStream, srv grpc.ServerStream) error {
	for {
		err := client.RecvMsg(msg)
		if err == io.EOF {
			break
		}

		if err != nil {
			return err
		}

		err = srv.SendMsg(msg)
		if err != nil {
			return err
		}
	}

	return nil
}

func (p *ApiProxy) StreamInterceptor() grpc.StreamServerInterceptor {
	return func(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
		md, _ := metadata.FromIncomingContext(ss.Context())
		if _, ok := md["proxyfrom"]; ok {
			return handler(srv, ss)
		}
		ca, err := p.Provider.GetCA()
		if err != nil {
			return err
		}
		certs, err := p.Provider.GetCertificate(nil)
		if err != nil {
			return err
		}
		tlsConfig, err := tls.New(
			tls.WithClientAuthType(tls.Mutual),
			tls.WithCACertPEM(ca),
			tls.WithKeypair(*certs),
		)
		return p.StreamProxy(ss, info.FullMethod, credentials.NewTLS(tlsConfig), srv)
	}
}

func (p *ApiProxy) StreamProxy(ss grpc.ServerStream, method string, creds credentials.TransportCredentials, srv interface{}, opts ...grpc.CallOption) error {
	var (
		err     error
		errors  *go_multierror.Error
		ok      bool
		targets []string
	)

	md, _ := metadata.FromIncomingContext(ss.Context())
	// default to target node specified in config or on cli
	if targets, ok = md["targets"]; !ok {
		targets = md[":authority"]
	}
	// Can discuss more on how to handle merging multiple streams later
	// but for now, ensure we only deal with a single target
	if len(targets) > 1 {
		targets = targets[:1]
	}

	proxyMd := metadata.New(make(map[string]string))
	proxyMd.Set("proxyfrom", md[":authority"]...)

	switch method {
	case "/machine.Machine/CopyOut":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		m := new(machine.CopyOutRequest)
		if err := ss.RecvMsg(m); err != nil {
			return err
		}
		// artificially limit this to only the first client/target until
		// we get multi-stream stuff sorted
		clientStream, err := clients[0].Conn.CopyOut(clients[0].Context, m)
		if err != nil {
			return err
		}
		var msg machine.StreamingData
		return copyClientServer(&msg, clientStream, ss.(grpc.ServerStream))
	case "/machine.Machine/Kubeconfig":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		m := new(empty.Empty)
		if err := ss.RecvMsg(m); err != nil {
			return err
		}
		// artificially limit this to only the first client/target until
		// we get multi-stream stuff sorted
		clientStream, err := clients[0].Conn.Kubeconfig(clients[0].Context, m)
		if err != nil {
			return err
		}
		var msg machine.StreamingData
		return copyClientServer(&msg, clientStream, ss.(grpc.ServerStream))
	case "/machine.Machine/LS":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		m := new(machine.LSRequest)
		if err := ss.RecvMsg(m); err != nil {
			return err
		}
		// artificially limit this to only the first client/target until
		// we get multi-stream stuff sorted
		clientStream, err := clients[0].Conn.LS(clients[0].Context, m)
		if err != nil {
			return err
		}
		var msg machine.FileInfo
		return copyClientServer(&msg, clientStream, ss.(grpc.ServerStream))
	case "/machine.Machine/Logs":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		m := new(machine.LogsRequest)
		if err := ss.RecvMsg(m); err != nil {
			return err
		}
		// artificially limit this to only the first client/target until
		// we get multi-stream stuff sorted
		clientStream, err := clients[0].Conn.Logs(clients[0].Context, m)
		if err != nil {
			return err
		}
		var msg common.Data
		return copyClientServer(&msg, clientStream, ss.(grpc.ServerStream))
	case "/machine.Machine/Read":
		// Initialize target clients
		clients, err := createMachineClient(targets, creds, proxyMd)
		if err != nil {
			break
		}
		m := new(machine.ReadRequest)
		if err := ss.RecvMsg(m); err != nil {
			return err
		}
		// artificially limit this to only the first client/target until
		// we get multi-stream stuff sorted
		clientStream, err := clients[0].Conn.Read(clients[0].Context, m)
		if err != nil {
			return err
		}
		var msg machine.StreamingData
		return copyClientServer(&msg, clientStream, ss.(grpc.ServerStream))

	}

	if err != nil {
		errors = go_multierror.Append(errors, err)
	}
	return errors.ErrorOrNil()
}

type runnerOSFn func(*proxyOSClient, interface{}, *sync.WaitGroup, chan proto.Message, chan error)

func proxyOSRunner(clients []*proxyOSClient, in interface{}, runner runnerOSFn) ([]proto.Message, error) {
	var (
		errors *go_multierror.Error
		wg     sync.WaitGroup
	)
	respCh := make(chan proto.Message, len(clients))
	errCh := make(chan error, len(clients))
	wg.Add(len(clients))
	for _, client := range clients {
		go runner(client, in, &wg, respCh, errCh)
	}
	wg.Wait()
	close(respCh)
	close(errCh)

	var response []proto.Message
	for resp := range respCh {
		response = append(response, resp)
	}
	for err := range errCh {
		errors = go_multierror.Append(errors, err)
	}
	return response, errors.ErrorOrNil()
}

type proxyOSClient struct {
	Conn     os.OSClient
	Context  context.Context
	Target   string
	DialOpts []grpc.DialOption
}

func proxyContainers(client *proxyOSClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Containers(client.Context, in.(*os.ContainersRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyDmesg(client *proxyOSClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Dmesg(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyMemory(client *proxyOSClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Memory(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyProcesses(client *proxyOSClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Processes(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyRestart(client *proxyOSClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Restart(client.Context, in.(*os.RestartRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyStats(client *proxyOSClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Stats(client.Context, in.(*os.StatsRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

type runnerMachineFn func(*proxyMachineClient, interface{}, *sync.WaitGroup, chan proto.Message, chan error)

func proxyMachineRunner(clients []*proxyMachineClient, in interface{}, runner runnerMachineFn) ([]proto.Message, error) {
	var (
		errors *go_multierror.Error
		wg     sync.WaitGroup
	)
	respCh := make(chan proto.Message, len(clients))
	errCh := make(chan error, len(clients))
	wg.Add(len(clients))
	for _, client := range clients {
		go runner(client, in, &wg, respCh, errCh)
	}
	wg.Wait()
	close(respCh)
	close(errCh)

	var response []proto.Message
	for resp := range respCh {
		response = append(response, resp)
	}
	for err := range errCh {
		errors = go_multierror.Append(errors, err)
	}
	return response, errors.ErrorOrNil()
}

type proxyMachineClient struct {
	Conn     machine.MachineClient
	Context  context.Context
	Target   string
	DialOpts []grpc.DialOption
}

func proxyMounts(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Mounts(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyReboot(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Reboot(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyReset(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Reset(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyServiceList(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.ServiceList(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyServiceRestart(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.ServiceRestart(client.Context, in.(*machine.ServiceRestartRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyServiceStart(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.ServiceStart(client.Context, in.(*machine.ServiceStartRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyServiceStop(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.ServiceStop(client.Context, in.(*machine.ServiceStopRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyShutdown(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Shutdown(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyUpgrade(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Upgrade(client.Context, in.(*machine.UpgradeRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyVersion(client *proxyMachineClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Version(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

type runnerTimeFn func(*proxyTimeClient, interface{}, *sync.WaitGroup, chan proto.Message, chan error)

func proxyTimeRunner(clients []*proxyTimeClient, in interface{}, runner runnerTimeFn) ([]proto.Message, error) {
	var (
		errors *go_multierror.Error
		wg     sync.WaitGroup
	)
	respCh := make(chan proto.Message, len(clients))
	errCh := make(chan error, len(clients))
	wg.Add(len(clients))
	for _, client := range clients {
		go runner(client, in, &wg, respCh, errCh)
	}
	wg.Wait()
	close(respCh)
	close(errCh)

	var response []proto.Message
	for resp := range respCh {
		response = append(response, resp)
	}
	for err := range errCh {
		errors = go_multierror.Append(errors, err)
	}
	return response, errors.ErrorOrNil()
}

type proxyTimeClient struct {
	Conn     time.TimeClient
	Context  context.Context
	Target   string
	DialOpts []grpc.DialOption
}

func proxyTime(client *proxyTimeClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Time(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyTimeCheck(client *proxyTimeClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.TimeCheck(client.Context, in.(*time.TimeRequest))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

type runnerNetworkFn func(*proxyNetworkClient, interface{}, *sync.WaitGroup, chan proto.Message, chan error)

func proxyNetworkRunner(clients []*proxyNetworkClient, in interface{}, runner runnerNetworkFn) ([]proto.Message, error) {
	var (
		errors *go_multierror.Error
		wg     sync.WaitGroup
	)
	respCh := make(chan proto.Message, len(clients))
	errCh := make(chan error, len(clients))
	wg.Add(len(clients))
	for _, client := range clients {
		go runner(client, in, &wg, respCh, errCh)
	}
	wg.Wait()
	close(respCh)
	close(errCh)

	var response []proto.Message
	for resp := range respCh {
		response = append(response, resp)
	}
	for err := range errCh {
		errors = go_multierror.Append(errors, err)
	}
	return response, errors.ErrorOrNil()
}

type proxyNetworkClient struct {
	Conn     network.NetworkClient
	Context  context.Context
	Target   string
	DialOpts []grpc.DialOption
}

func proxyRoutes(client *proxyNetworkClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Routes(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func proxyInterfaces(client *proxyNetworkClient, in interface{}, wg *sync.WaitGroup, respCh chan proto.Message, errCh chan error) {
	defer wg.Done()
	resp, err := client.Conn.Interfaces(client.Context, in.(*empty.Empty))
	if err != nil {
		errCh <- err
		return
	}
	resp.Response[0].Metadata = &NodeMetadata{Hostname: client.Target}
	respCh <- resp
}

func createOSClient(targets []string, creds credentials.TransportCredentials, proxyMd metadata.MD) ([]*proxyOSClient, error) {
	var errors *go_multierror.Error
	clients := make([]*proxyOSClient, 0, len(targets))
	for _, target := range targets {
		c := &proxyOSClient{
			// TODO change the context to be more useful ( ex cancelable )
			Context: metadata.NewOutgoingContext(context.Background(), proxyMd),
			Target:  target,
		}
		// TODO: i think we potentially leak a client here,
		// we should close the request // cancel the context if it errors
		// Explicitly set OSD port
		conn, err := grpc.Dial(fmt.Sprintf("%s:%d", target, 50000), grpc.WithTransportCredentials(creds))
		if err != nil {
			// TODO: probably worth wrapping err to add some context about the target
			errors = go_multierror.Append(errors, err)
			continue
		}
		c.Conn = os.NewOSClient(conn)
		clients = append(clients, c)
	}
	return clients, errors.ErrorOrNil()
}

func createMachineClient(targets []string, creds credentials.TransportCredentials, proxyMd metadata.MD) ([]*proxyMachineClient, error) {
	var errors *go_multierror.Error
	clients := make([]*proxyMachineClient, 0, len(targets))
	for _, target := range targets {
		c := &proxyMachineClient{
			// TODO change the context to be more useful ( ex cancelable )
			Context: metadata.NewOutgoingContext(context.Background(), proxyMd),
			Target:  target,
		}
		// TODO: i think we potentially leak a client here,
		// we should close the request // cancel the context if it errors
		// Explicitly set OSD port
		conn, err := grpc.Dial(fmt.Sprintf("%s:%d", target, 50000), grpc.WithTransportCredentials(creds))
		if err != nil {
			// TODO: probably worth wrapping err to add some context about the target
			errors = go_multierror.Append(errors, err)
			continue
		}
		c.Conn = machine.NewMachineClient(conn)
		clients = append(clients, c)
	}
	return clients, errors.ErrorOrNil()
}

func createTimeClient(targets []string, creds credentials.TransportCredentials, proxyMd metadata.MD) ([]*proxyTimeClient, error) {
	var errors *go_multierror.Error
	clients := make([]*proxyTimeClient, 0, len(targets))
	for _, target := range targets {
		c := &proxyTimeClient{
			// TODO change the context to be more useful ( ex cancelable )
			Context: metadata.NewOutgoingContext(context.Background(), proxyMd),
			Target:  target,
		}
		// TODO: i think we potentially leak a client here,
		// we should close the request // cancel the context if it errors
		// Explicitly set OSD port
		conn, err := grpc.Dial(fmt.Sprintf("%s:%d", target, 50000), grpc.WithTransportCredentials(creds))
		if err != nil {
			// TODO: probably worth wrapping err to add some context about the target
			errors = go_multierror.Append(errors, err)
			continue
		}
		c.Conn = time.NewTimeClient(conn)
		clients = append(clients, c)
	}
	return clients, errors.ErrorOrNil()
}

func createNetworkClient(targets []string, creds credentials.TransportCredentials, proxyMd metadata.MD) ([]*proxyNetworkClient, error) {
	var errors *go_multierror.Error
	clients := make([]*proxyNetworkClient, 0, len(targets))
	for _, target := range targets {
		c := &proxyNetworkClient{
			// TODO change the context to be more useful ( ex cancelable )
			Context: metadata.NewOutgoingContext(context.Background(), proxyMd),
			Target:  target,
		}
		// TODO: i think we potentially leak a client here,
		// we should close the request // cancel the context if it errors
		// Explicitly set OSD port
		conn, err := grpc.Dial(fmt.Sprintf("%s:%d", target, 50000), grpc.WithTransportCredentials(creds))
		if err != nil {
			// TODO: probably worth wrapping err to add some context about the target
			errors = go_multierror.Append(errors, err)
			continue
		}
		c.Conn = network.NewNetworkClient(conn)
		clients = append(clients, c)
	}
	return clients, errors.ErrorOrNil()
}

type Registrator struct {
	os.OSClient
	machine.MachineClient
	time.TimeClient
	network.NetworkClient
}

func (r *Registrator) Register(s *grpc.Server) {
	os.RegisterOSServer(s, r)
	machine.RegisterMachineServer(s, r)
	time.RegisterTimeServer(s, r)
	network.RegisterNetworkServer(s, r)
}

func (r *Registrator) Containers(ctx context.Context, in *os.ContainersRequest) (*os.ContainersReply, error) {
	return r.OSClient.Containers(ctx, in)
}

func (r *Registrator) Dmesg(ctx context.Context, in *empty.Empty) (*common.DataReply, error) {
	return r.OSClient.Dmesg(ctx, in)
}

func (r *Registrator) Memory(ctx context.Context, in *empty.Empty) (*os.MemInfoReply, error) {
	return r.OSClient.Memory(ctx, in)
}

func (r *Registrator) Processes(ctx context.Context, in *empty.Empty) (*os.ProcessesReply, error) {
	return r.OSClient.Processes(ctx, in)
}

func (r *Registrator) Restart(ctx context.Context, in *os.RestartRequest) (*os.RestartReply, error) {
	return r.OSClient.Restart(ctx, in)
}

func (r *Registrator) Stats(ctx context.Context, in *os.StatsRequest) (*os.StatsReply, error) {
	return r.OSClient.Stats(ctx, in)
}

func (r *Registrator) CopyOut(in *machine.CopyOutRequest, srv machine.Machine_CopyOutServer) error {
	client, err := r.MachineClient.CopyOut(srv.Context(), in)
	if err != nil {
		return err
	}
	var msg machine.StreamingData
	return copyClientServer(&msg, client, srv)
}

func (r *Registrator) Kubeconfig(in *empty.Empty, srv machine.Machine_KubeconfigServer) error {
	client, err := r.MachineClient.Kubeconfig(srv.Context(), in)
	if err != nil {
		return err
	}
	var msg machine.StreamingData
	return copyClientServer(&msg, client, srv)
}

func (r *Registrator) LS(in *machine.LSRequest, srv machine.Machine_LSServer) error {
	client, err := r.MachineClient.LS(srv.Context(), in)
	if err != nil {
		return err
	}
	var msg machine.FileInfo
	return copyClientServer(&msg, client, srv)
}

func (r *Registrator) Logs(in *machine.LogsRequest, srv machine.Machine_LogsServer) error {
	client, err := r.MachineClient.Logs(srv.Context(), in)
	if err != nil {
		return err
	}
	var msg common.Data
	return copyClientServer(&msg, client, srv)
}

func (r *Registrator) Mounts(ctx context.Context, in *empty.Empty) (*machine.MountsReply, error) {
	return r.MachineClient.Mounts(ctx, in)
}

func (r *Registrator) Read(in *machine.ReadRequest, srv machine.Machine_ReadServer) error {
	client, err := r.MachineClient.Read(srv.Context(), in)
	if err != nil {
		return err
	}
	var msg machine.StreamingData
	return copyClientServer(&msg, client, srv)
}

func (r *Registrator) Reboot(ctx context.Context, in *empty.Empty) (*machine.RebootReply, error) {
	return r.MachineClient.Reboot(ctx, in)
}

func (r *Registrator) Reset(ctx context.Context, in *empty.Empty) (*machine.ResetReply, error) {
	return r.MachineClient.Reset(ctx, in)
}

func (r *Registrator) ServiceList(ctx context.Context, in *empty.Empty) (*machine.ServiceListReply, error) {
	return r.MachineClient.ServiceList(ctx, in)
}

func (r *Registrator) ServiceRestart(ctx context.Context, in *machine.ServiceRestartRequest) (*machine.ServiceRestartReply, error) {
	return r.MachineClient.ServiceRestart(ctx, in)
}

func (r *Registrator) ServiceStart(ctx context.Context, in *machine.ServiceStartRequest) (*machine.ServiceStartReply, error) {
	return r.MachineClient.ServiceStart(ctx, in)
}

func (r *Registrator) ServiceStop(ctx context.Context, in *machine.ServiceStopRequest) (*machine.ServiceStopReply, error) {
	return r.MachineClient.ServiceStop(ctx, in)
}

func (r *Registrator) Shutdown(ctx context.Context, in *empty.Empty) (*machine.ShutdownReply, error) {
	return r.MachineClient.Shutdown(ctx, in)
}

func (r *Registrator) Upgrade(ctx context.Context, in *machine.UpgradeRequest) (*machine.UpgradeReply, error) {
	return r.MachineClient.Upgrade(ctx, in)
}

func (r *Registrator) Start(ctx context.Context, in *machine.StartRequest) (*machine.StartReply, error) {
	return r.MachineClient.Start(ctx, in)
}

func (r *Registrator) Stop(ctx context.Context, in *machine.StopRequest) (*machine.StopReply, error) {
	return r.MachineClient.Stop(ctx, in)
}

func (r *Registrator) Version(ctx context.Context, in *empty.Empty) (*machine.VersionReply, error) {
	return r.MachineClient.Version(ctx, in)
}

func (r *Registrator) Time(ctx context.Context, in *empty.Empty) (*time.TimeReply, error) {
	return r.TimeClient.Time(ctx, in)
}

func (r *Registrator) TimeCheck(ctx context.Context, in *time.TimeRequest) (*time.TimeReply, error) {
	return r.TimeClient.TimeCheck(ctx, in)
}

func (r *Registrator) Routes(ctx context.Context, in *empty.Empty) (*network.RoutesReply, error) {
	return r.NetworkClient.Routes(ctx, in)
}

func (r *Registrator) Interfaces(ctx context.Context, in *empty.Empty) (*network.InterfacesReply, error) {
	return r.NetworkClient.Interfaces(ctx, in)
}

type LocalOSClient struct {
	os.OSClient
}

func NewLocalOSClient() (os.OSClient, error) {
	conn, err := grpc.Dial("unix:"+constants.OSSocketPath,
		grpc.WithInsecure(),
	)
	if err != nil {
		return nil, err
	}
	return &LocalOSClient{
		OSClient: os.NewOSClient(conn),
	}, nil
}

func (c *LocalOSClient) Containers(ctx context.Context, in *os.ContainersRequest, opts ...grpc.CallOption) (*os.ContainersReply, error) {
	return c.OSClient.Containers(ctx, in, opts...)
}

func (c *LocalOSClient) Dmesg(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.DataReply, error) {
	return c.OSClient.Dmesg(ctx, in, opts...)
}

func (c *LocalOSClient) Memory(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*os.MemInfoReply, error) {
	return c.OSClient.Memory(ctx, in, opts...)
}

func (c *LocalOSClient) Processes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*os.ProcessesReply, error) {
	return c.OSClient.Processes(ctx, in, opts...)
}

func (c *LocalOSClient) Restart(ctx context.Context, in *os.RestartRequest, opts ...grpc.CallOption) (*os.RestartReply, error) {
	return c.OSClient.Restart(ctx, in, opts...)
}

func (c *LocalOSClient) Stats(ctx context.Context, in *os.StatsRequest, opts ...grpc.CallOption) (*os.StatsReply, error) {
	return c.OSClient.Stats(ctx, in, opts...)
}

type LocalMachineClient struct {
	machine.MachineClient
}

func NewLocalMachineClient() (machine.MachineClient, error) {
	conn, err := grpc.Dial("unix:"+constants.MachineSocketPath,
		grpc.WithInsecure(),
	)
	if err != nil {
		return nil, err
	}
	return &LocalMachineClient{
		MachineClient: machine.NewMachineClient(conn),
	}, nil
}

func (c *LocalMachineClient) CopyOut(ctx context.Context, in *machine.CopyOutRequest, opts ...grpc.CallOption) (machine.Machine_CopyOutClient, error) {
	return c.MachineClient.CopyOut(ctx, in, opts...)
}

func (c *LocalMachineClient) Kubeconfig(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (machine.Machine_KubeconfigClient, error) {
	return c.MachineClient.Kubeconfig(ctx, in, opts...)
}

func (c *LocalMachineClient) LS(ctx context.Context, in *machine.LSRequest, opts ...grpc.CallOption) (machine.Machine_LSClient, error) {
	return c.MachineClient.LS(ctx, in, opts...)
}

func (c *LocalMachineClient) Logs(ctx context.Context, in *machine.LogsRequest, opts ...grpc.CallOption) (machine.Machine_LogsClient, error) {
	return c.MachineClient.Logs(ctx, in, opts...)
}

func (c *LocalMachineClient) Mounts(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*machine.MountsReply, error) {
	return c.MachineClient.Mounts(ctx, in, opts...)
}

func (c *LocalMachineClient) Read(ctx context.Context, in *machine.ReadRequest, opts ...grpc.CallOption) (machine.Machine_ReadClient, error) {
	return c.MachineClient.Read(ctx, in, opts...)
}

func (c *LocalMachineClient) Reboot(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*machine.RebootReply, error) {
	return c.MachineClient.Reboot(ctx, in, opts...)
}

func (c *LocalMachineClient) Reset(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*machine.ResetReply, error) {
	return c.MachineClient.Reset(ctx, in, opts...)
}

func (c *LocalMachineClient) ServiceList(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*machine.ServiceListReply, error) {
	return c.MachineClient.ServiceList(ctx, in, opts...)
}

func (c *LocalMachineClient) ServiceRestart(ctx context.Context, in *machine.ServiceRestartRequest, opts ...grpc.CallOption) (*machine.ServiceRestartReply, error) {
	return c.MachineClient.ServiceRestart(ctx, in, opts...)
}

func (c *LocalMachineClient) ServiceStart(ctx context.Context, in *machine.ServiceStartRequest, opts ...grpc.CallOption) (*machine.ServiceStartReply, error) {
	return c.MachineClient.ServiceStart(ctx, in, opts...)
}

func (c *LocalMachineClient) ServiceStop(ctx context.Context, in *machine.ServiceStopRequest, opts ...grpc.CallOption) (*machine.ServiceStopReply, error) {
	return c.MachineClient.ServiceStop(ctx, in, opts...)
}

func (c *LocalMachineClient) Shutdown(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*machine.ShutdownReply, error) {
	return c.MachineClient.Shutdown(ctx, in, opts...)
}

func (c *LocalMachineClient) Upgrade(ctx context.Context, in *machine.UpgradeRequest, opts ...grpc.CallOption) (*machine.UpgradeReply, error) {
	return c.MachineClient.Upgrade(ctx, in, opts...)
}

func (c *LocalMachineClient) Start(ctx context.Context, in *machine.StartRequest, opts ...grpc.CallOption) (*machine.StartReply, error) {
	return c.MachineClient.Start(ctx, in, opts...)
}

func (c *LocalMachineClient) Stop(ctx context.Context, in *machine.StopRequest, opts ...grpc.CallOption) (*machine.StopReply, error) {
	return c.MachineClient.Stop(ctx, in, opts...)
}

func (c *LocalMachineClient) Version(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*machine.VersionReply, error) {
	return c.MachineClient.Version(ctx, in, opts...)
}

type LocalTimeClient struct {
	time.TimeClient
}

func NewLocalTimeClient() (time.TimeClient, error) {
	conn, err := grpc.Dial("unix:"+constants.TimeSocketPath,
		grpc.WithInsecure(),
	)
	if err != nil {
		return nil, err
	}
	return &LocalTimeClient{
		TimeClient: time.NewTimeClient(conn),
	}, nil
}

func (c *LocalTimeClient) Time(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*time.TimeReply, error) {
	return c.TimeClient.Time(ctx, in, opts...)
}

func (c *LocalTimeClient) TimeCheck(ctx context.Context, in *time.TimeRequest, opts ...grpc.CallOption) (*time.TimeReply, error) {
	return c.TimeClient.TimeCheck(ctx, in, opts...)
}

type LocalNetworkClient struct {
	network.NetworkClient
}

func NewLocalNetworkClient() (network.NetworkClient, error) {
	conn, err := grpc.Dial("unix:"+constants.NetworkSocketPath,
		grpc.WithInsecure(),
	)
	if err != nil {
		return nil, err
	}
	return &LocalNetworkClient{
		NetworkClient: network.NewNetworkClient(conn),
	}, nil
}

func (c *LocalNetworkClient) Routes(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*network.RoutesReply, error) {
	return c.NetworkClient.Routes(ctx, in, opts...)
}

func (c *LocalNetworkClient) Interfaces(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*network.InterfacesReply, error) {
	return c.NetworkClient.Interfaces(ctx, in, opts...)
}
